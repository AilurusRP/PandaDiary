import 'dart:io';
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:panda_diary/constants/package_name.dart';
import 'package:path/path.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:uuid/uuid.dart';

import '../db/data_models/note_data.dart';
import '../db/db_manager.dart';

void exportNotes({required Function(Object?) onFall}) async {
  Permission.manageExternalStorage.request();
  List<NoteData> data = await _getAllNotesData();

  String content = data
      .map((noteData) =>
          "< note-start ${noteData.id} ${noteData.title.replaceAll(" ", "%20")} >\n${noteData.content}\n< note-end ${noteData.id} >\n")
      .join("\n");

  _writeTextToPublicDocument(fileName: '$packageName.backup', content: content)
      .onError((err, stackTrace) {
    onFall(err);
    debugPrint(stackTrace.toString());
  });
}

Future<void> importNotes({required Function(Object?) onFall}) async {
  Permission.manageExternalStorage.request();
  final Directory dir = Directory("/storage/emulated/0/$packageName");
  if (!await dir.exists()) {
    await dir.create(recursive: true);
  }
  final Directory importDir = Directory("${dir.path}/import");
  var childFilesAndDirs = importDir.listSync();

  var noteFiles = childFilesAndDirs.where(
      (fse) => fse is File && basename(fse.path) == "$packageName.backup");
  if (noteFiles.length > 1) {
    onFall(Exception("More than 1 backup files!"));
    return;
  }
  if (noteFiles.isEmpty) return;

  String noteBackupContent =
      await (noteFiles.toList()[0] as File).readAsString();

  final dbManager = await (DBManager<NoteData>(
          tableName: NoteData.tableName, fields: NoteData.fields))
      .open();
  List<NoteData> notesInDatabase = await dbManager.query(NoteData.fromMap);

  int maxOrd = notesInDatabase.isNotEmpty
      ? notesInDatabase.map((noteData) => noteData.ord).reduce(max)
      : 0;

  List<NoteData> noteDataList = _toNoteData(noteBackupContent);

  for (int i = 0; i < noteDataList.length; i++) {
    await _importNote(noteDataList[i], i + maxOrd, dbManager, notesInDatabase)
        .onError((err, stackTrace) {
      onFall(err);
    });
  }
}

List<NoteData> _toNoteData(String backupContent) {
  List<String> splitLinesOfBackupContent = backupContent.split("\n");
  final List<NoteData> results = [];
  String? id;
  String? title;
  String content = "";
  bool isInNoteScope = false;
  splitLinesOfBackupContent.forEach((line) {
    if (line.startsWith("<") &&
        line.endsWith(">") &&
        Uuid.isValidUUID(fromString: line.split(" ")[2])) {
      List<String> splitLine = line.split(" ");
      if (splitLine[1] == "note-start") {
        isInNoteScope = true;
        id = splitLine[2];
        title = splitLine[3];
      } else if (isInNoteScope &&
          splitLine[1] == "note-end" &&
          splitLine[2] == id) {
        if (id == null) throw Exception("Id not found!");
        if (title == null) throw Exception("Title not found");
        if (content.endsWith("\n")) {
          content = content.substring(0, content.length - 1);
        }
        results.add(NoteData(id: id, title: title!, content: content, ord: 0));
        isInNoteScope = false;
        content = "";
      }
    } else {
      if (isInNoteScope) content += "$line\n";
    }
  });
  return results;
}

Future<void> _importNote(NoteData noteDataBackup, int ord,
    DBManager<NoteData> dbManager, List<NoteData> notesInDatabase) async {
  String id = noteDataBackup.id;
  String title = noteDataBackup.title;
  String content = noteDataBackup.content;

  List<NoteData> duplicatedNotes =
      notesInDatabase.where((noteData) => noteData.id == id).toList();
  assert(duplicatedNotes.length <= 1);

  if (duplicatedNotes.isNotEmpty) {
    if (duplicatedNotes[0].content == content) return;
    if (notesInDatabase.any((noteData) =>
        noteData.title == "$title(1)" && noteData.content == content)) {
      return;
    }
    id = const Uuid().v4();
    if (duplicatedNotes[0].title == title) title = "$title(1)";
  }

  final noteData = NoteData(id: id, title: title, content: content, ord: ord);

  dbManager.insert(noteData);
}

void createExportDirAndImportDir() async {
  Permission.manageExternalStorage.request();
  final Directory dir = Directory("/storage/emulated/0/$packageName");
  if (!await dir.exists()) {
    await dir.create(recursive: true);
  }
  final Directory exportDir = Directory("${dir.path}/export");
  final Directory importDir = Directory("${dir.path}/import");
  exportDir.create();
  importDir.create();
}

Future<List<NoteData>> _getAllNotesData() async {
  List<NoteData> value = [];
  final dbManager = DBManager<NoteData>(
      tableName: NoteData.tableName, fields: NoteData.fields);
  value = await (await dbManager.open()).query(NoteData.fromMap);
  return value;
}

// Functions below are generated by Proton Lumo AI
Future<void> _writeTextToPublicDocument({
  required String fileName,
  required String content,
}) async {
  final Directory dir = Directory("/storage/emulated/0/$packageName");

  if (!await dir.exists()) {
    await dir.create(recursive: true);
  }

  final Directory exportDir = Directory("${dir.path}/export");

  final File file = File('${exportDir.path}/$fileName');

  await file.writeAsString(content, flush: true);
}
