import 'dart:io';
import 'dart:math';
import 'package:panda_diary/constants/package_name.dart';
import 'package:path/path.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:uuid/uuid.dart';

import '../db/data_models/note_data.dart';
import '../db/db_manager.dart';

void exportNotes({required Function(Object?) onFall}) async {
  Permission.manageExternalStorage.request();
  List<NoteData> data = await _getAllNotesData();
  data.forEach((noteData) {
    String escapedTitle = noteData.title
        .split("")
        .map((char) => ("|\\?*<\":>+[]/'".contains(char)) ? "_" : char)
        .join("");
    _writeTextToPublicDocument(
      fileName: '$packageName.$escapedTitle.${noteData.id}.backup',
      content:
          "id:${noteData.id}\ntitle:${noteData.title}\ncontent:\n${noteData.content}",
    ).onError((err, stackTrace) {
      onFall(err);
    });
  });
}

Future<void> importNotes({required Function(Object?) onFall}) async {
  Permission.manageExternalStorage.request();
  final Directory dir = Directory("/storage/emulated/0/$packageName");
  if (!await dir.exists()) {
    await dir.create(recursive: true);
  }
  final Directory importDir = Directory("${dir.path}/import");
  var childFilesAndDirs = importDir.listSync();
  var noteFiles = childFilesAndDirs.where(
      (fse) => fse is File && _isValidNoteBackupFileName(basename(fse.path)));

  final dbManager = await (DBManager<NoteData>(
          tableName: NoteData.tableName, fields: NoteData.fields))
      .open();
  List<NoteData> notesInDatabase = await dbManager.query(NoteData.fromMap);

  for (int i = 0; i < noteFiles.length; i++) {
    await _importNote(
            noteFiles.toList()[i] as File,
            i + notesInDatabase.map((noteData) => noteData.ord).reduce(max),
            dbManager,
            notesInDatabase)
        .onError((err, stackTrace) {
      onFall(err);
    });
  }
}

Future<void> _importNote(File file, int ord, DBManager<NoteData> dbManager,
    List<NoteData> notesInDatabase) async {
  String backupText = await file.readAsString();
  if (!_isValidNoteDataBackup(basename(file.path), backupText)) {
    throw Exception("The note backup is not valid.");
  }

  var backupTextLines = backupText.split("\n");
  String id = backupTextLines[0].split(":")[1];
  String title = backupTextLines[1].split(":").sublist(1).join(":");
  String content = backupTextLines.sublist(3).join("\n");

  List<NoteData> duplicatedNotes =
      notesInDatabase.where((noteData) => noteData.id == id).toList();
  assert(duplicatedNotes.length <= 1);

  if (duplicatedNotes.isNotEmpty) {
    if (duplicatedNotes[0].content == content) return;
    id = const Uuid().v4();
    if (duplicatedNotes[0].title == title) title = "$title(1)";
  }

  final noteData = NoteData(
      id: id,
      title: title,
      content: backupTextLines.sublist(3).join("\n"),
      ord: ord);

  dbManager.insert(noteData);
}

bool _isValidNoteBackupFileName(String fileName) {
  var splitFileName = fileName.split(".");
  if (splitFileName.length < 4) return false;
  if (splitFileName[0] != packageName) return false;
  if (splitFileName[splitFileName.length - 1] != "backup") return false;

  var uuidPattern = RegExp(
      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}\$");
  if (!uuidPattern.hasMatch(splitFileName[splitFileName.length - 2])) {
    return false;
  }

  return true;
}

bool _isValidNoteDataBackup(String fileName, String content) {
  var contentList = content.split("\n");
  var splitFileNameList = fileName.split(".");
  var id = splitFileNameList[splitFileNameList.length - 2];

  if (contentList[0].split(":").length != 2) {
    return false;
  }
  if (contentList[0].split(":")[0] != "id") return false;
  if (contentList[0].split(":")[1] != id) return false;

  if (contentList[1].split(":").length != 2) {
    return false;
  }
  if (contentList[1].split(":")[0] != "title") return false;

  if (contentList[2] != "content:") return false;

  return true;
}

void createExportDirAndImportDir() async {
  Permission.manageExternalStorage.request();
  final Directory dir = Directory("/storage/emulated/0/$packageName");
  if (!await dir.exists()) {
    await dir.create(recursive: true);
  }
  final Directory exportDir = Directory("${dir.path}/export");
  final Directory importDir = Directory("${dir.path}/import");
  exportDir.create();
  importDir.create();
}

Future<List<NoteData>> _getAllNotesData() async {
  List<NoteData> value = [];
  final dbManager = DBManager<NoteData>(
      tableName: NoteData.tableName, fields: NoteData.fields);
  value = await (await dbManager.open()).query(NoteData.fromMap);
  return value;
}

// Functions below are generated by Proton Lumo AI
Future<void> _writeTextToPublicDocument({
  required String fileName,
  required String content,
}) async {
  final Directory dir = Directory("/storage/emulated/0/$packageName");

  if (!await dir.exists()) {
    await dir.create(recursive: true);
  }

  final Directory exportDir = Directory("${dir.path}/export");

  final File file = File('${exportDir.path}/$fileName');

  await file.writeAsString(content, flush: true);
}
